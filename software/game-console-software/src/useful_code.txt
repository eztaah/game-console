void e_draw_moving_rectangle(int16_t new_pos_x, int16_t new_pos_y, int16_t old_pos_x, int16_t old_pos_y,
                           int16_t width, int16_t height, uint16_t color, uint16_t background_color)
{
    // Calcul de la zone de chevauchement
    int left = old_pos_x;
    if (new_pos_x > left) left = new_pos_x;
    int right = old_pos_x + width;
    if (new_pos_x + width < right) right = new_pos_x + width;
    int top = old_pos_y;
    if (new_pos_y > top) top = new_pos_y;
    int bottom = old_pos_y + height;
    if (new_pos_y + height < bottom) bottom = new_pos_y + height;

    // Dessin des nouvelles zones
    if (new_pos_x < old_pos_x) {
        TFT_Box(e_safe_convert(new_pos_x, "0"), e_safe_convert(new_pos_y, "0"), e_safe_convert(old_pos_x, "0"), e_safe_convert(new_pos_y + height, "0"), color);
    }
    if (new_pos_x > old_pos_x) {
        TFT_Box(e_safe_convert(old_pos_x + width, "0"), e_safe_convert(new_pos_y, "0"), e_safe_convert(new_pos_x + width, "0"), e_safe_convert(new_pos_y + height, "0"), color);
    }
    if (new_pos_y < old_pos_y) {
        TFT_Box(e_safe_convert(new_pos_x, "0"), e_safe_convert(new_pos_y, "0"), e_safe_convert(new_pos_x + width, "0"), e_safe_convert(old_pos_y, "0"), color);
    }
    if (new_pos_y > old_pos_y) {
        TFT_Box(e_safe_convert(new_pos_x, "0"), e_safe_convert(old_pos_y + height, "0"), e_safe_convert(new_pos_x + width, "0"), e_safe_convert(new_pos_y + height, "0"), color);
    }

    // Nettoyage des anciennes zones
    if (old_pos_x < new_pos_x) {
        TFT_Box(e_safe_convert(old_pos_x, "0"), e_safe_convert(old_pos_y, "0"), e_safe_convert(new_pos_x, "0"), e_safe_convert(old_pos_y + height, "0"), background_color);
    }
    if (old_pos_x > new_pos_x) {
        TFT_Box(e_safe_convert(right, "0"), e_safe_convert(old_pos_y, "0"), e_safe_convert(old_pos_x + width, "0"), e_safe_convert(old_pos_y + height, "0"), background_color);
    }
    if (old_pos_y < new_pos_y) {
        TFT_Box(e_safe_convert(old_pos_x, "0"), e_safe_convert(old_pos_y, "0"), e_safe_convert(old_pos_x + width, "0"), e_safe_convert(new_pos_y, "0"), background_color);
    }
    if (old_pos_y > new_pos_y) {
        TFT_Box(e_safe_convert(old_pos_x, "0"), e_safe_convert(bottom, "0"), e_safe_convert(old_pos_x + width, "0"), e_safe_convert(old_pos_y + height, "0"), background_color);
    }
}


---------------------------------------------

    while(1) {
        int16_t variable1 = PORTBbits.RB0;
        if (e_is_button_down(BUTTON_UP)) {
            e_fill_screen(BLUE);
        }
        else if (e_is_button_down(BUTTON_DOWN)) {
            e_fill_screen(GREEN);
        }
        else if (e_is_button_down(BUTTON_RIGHT)) {
            e_fill_screen(MAGENTA);
        }
        else if (e_is_button_down(BUTTON_LEFT)) {
            e_fill_screen(BROWN);
        }
        else if (e_is_button_down(BUTTON_A)) {
            e_fill_screen(RED);
        }
        else if (e_is_button_down(BUTTON_B)) {
            e_fill_screen(LIGHTBLUE);
        }
        else if (e_is_button_down(BUTTON_HOME)) {
            e_fill_screen(CYAN);
        }
        else {
            e_fill_screen(BLACK);
        }
    }



-----------------------------------------

void play_tetris(void){
    e_play_E4(400);
    e_play_B3(200);
    e_play_C4(200);
    e_play_D4(400);
    e_play_C4(200);
    e_play_B3(200);
    e_play_A3(400);
    e_play_A3(200);
    _e_stop_buzzer();
    e_play_C4(200);
    e_play_E4(400);
    _e_stop_buzzer();
}







-------------------------------------------------------

e_draw_icon(rl_loading, 2, 2, 103, 76, 3);

const uint16_t rl_loading[] = {
    0x00E9, 0x00E9, 
    ......
    0x00E9, 0x00E9
};






--------------------------------------------------------
ECRIRE DANS LA FLASH

void write_flash(uint16_t address, uint8_t value){
    INTCONbits.GIE = 0; // D�sactiver les interruptions
    TBLPTRU = 0x00;  // Partie sup�rieure de l'adresse (pour une adresse de 16 bits, c'est 0)
    TBLPTRH = (uint8_t)((address >> 8) & 0xFF);   // Partie haute de l'adresse
    TBLPTRL = (uint8_t)(address & 0xFF);          // Partie basse de l'adresse
    TABLAT = value;     // Valeur � �crire
    asm("TBLWT*+");
    EECON1bits.EEPGD = 1;    // Acc�s � la m�moire flash
    EECON1bits.CFGS = 0;     // Acc�s � la m�moire de programme
    EECON1bits.WREN = 1;     // Activation de l'�criture en m�moire flash
    EECON2 = 0x55;
    EECON2 = 0x0AA;
    EECON1bits.WR = 1;       // D�clenche l'�criture
    while (EECON1bits.WR){};
    EECON1bits.WREN = 0;    // D�sactivation de l'�criture
    INTCONbits.GIE = 1;     // R�activer les interruptions
}

int16_t read_flash(uint16_t address){
    TBLPTRU = 0x00;  // Partie sup�rieure de l'adresse (pour une adresse de 16 bits, c'est 0)
    TBLPTRH = (uint8_t)((address >> 8) & 0xFF);   // Partie haute de l'adresse
    TBLPTRL = (uint8_t)(address & 0xFF);          // Partie basse de l'adresse
    asm("TBLRD*+");     // Instruction d'assemblage pour lire la m�moire flash
    return TABLAT;      // Retourne la valeur lue
}




if (e_is_button_down(BUTTON_A)) {
    switch (cursor_position) {
        case 0:
            write_EEPROM(0x01, 0x03);
            write_EEPROM(0x02, 0x04);
            break;
        case 1:
            score = read_EEPROM(0x01);
            break;
        case 2:
            score = read_EEPROM(0x02);
            break;
    }
}

